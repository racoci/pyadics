# P-Adic Arithmetic (Integer Version)

This repository contains an implementation of p-adic arithmetic for integers using Python. The goal is to represent p-adic numbers as infinite streams of digits (in base `p`) without consuming the original digit generators. This allows multiple operations on the same p-adic number without losing its data.

## Current Features

- **Stable Generation of Digits:**  
  The `stable_p_adic(p, seed)` function produces a stable p-adic number whose digits are generated by a fixed random seed. The digit factory can be cloned and reused, ensuring reproducible expansions.

- **Basic Constructors:**  
  - `p_adic_zero(p)` creates a p-adic zero number.
  - `p_adic_one(p)` creates a p-adic one number.

- **Basic Arithmetic Operations:**
  - **Addition (`__add__`)**: Supports adding two p-adic numbers (with the same prime base) digit-by-digit. If one number is shorter, it assumes infinite trailing zeros.
  - **Multiplication (`__mul__`)**:  
    - Multiplying by a small integer: Implemented by handling carries and producing new digits as needed.
    - Multiplying two p-adic numbers: A naive convolution-based approach is used, continuously reading digits from each factor and computing product digits. While this approach can work for infinite expansions, it is currently naive and may not be efficient for large computations.
  - **Negation (`__neg__`)**: Computes the additive inverse of a p-adic number.
  - **Equality (`__eq__`, `__ne__`)**: Tests equality of p-adic numbers by comparing a fixed number of digits.

- **Bit Shifts (`<<` and `>>`)**:  
  - `x << n` and `x >> n` allow you to multiply or divide by powers of p by adjusting the digit stream. Currently, these just prepend or skip digits, effectively shifting the representation. More sophisticated normalization or exponent tracking may be needed in the future.

- **Conversion from Integers (`p_adic_from_integer`)**:  
  Allows creating a p-adic number from a positive integer by expanding it into base-p digits.

## Current Limitations

- **Normalization:**  
  While some normalization occurs, a full normalization to remove unnecessary leading zeros or manage infinite expansions is not fully implemented. As a result, some operations may produce expansions that are not fully simplified.

- **Inverses for Non-Units:**  
  Currently, the code does not implement multiplicative inverses for general p-adic numbers. Inversion in p-adics is only defined for units, and a digit-by-digit approach needs to be implemented.

- **Divisibility Tests and Fractional p-Adics:**  
  At the moment, there is no direct method to test divisibility properties (other than indirectly through arithmetic operations) or handle fractional (negative exponent) p-adics.

## Future Directions

1. **Multiplicative Inverse for Units:**
   Implementing the Hensel lifting process to find inverses for p-adic units. This involves using known step-by-step algorithms to refine the inverse approximation modulo higher and higher powers of p.

2. **Divisibility Tests:**
   Adding a method to test whether one p-adic integer divides another. This can be approached by examining digit patterns or applying known theorems about divisibility in p-adic integers.

3. **Fractional p-Adics:**
   Eventually, support p-adic rationals by wrapping an integer `P_Adic` and an exponent. This will allow representing elements of the p-adic field (not just the ring of p-adic integers). Negative exponents correspond to dividing by powers of p, which will involve careful handling of digit shifts and normalization.

4. **Performance Improvements:**
   Explore more efficient digit-by-digit multiplication algorithms (such as Karatsuba or FFT-based methods, if applicable in the p-adic setting) to handle large expansions more quickly.

5. **Normalization Enhancements:**
   Implement a robust normalization procedure that ensures each p-adic number's representation is canonical. This might involve calling `normalize()` after arithmetic operations or shifts, removing unnecessary zeros, and adjusting internal state accordingly.

## Contributing and Feedback

Contributions, bug reports, and feedback are welcome. As the project evolves, more operations, tests, and examples will be added to ensure correctness and efficiency.

## Disclaimer

This implementation is a work in progress and primarily educational. The code may not be optimized or fully accurate for large-scale computations or advanced p-adic analysis. Users should test and validate the arithmetic against known results where possible.
